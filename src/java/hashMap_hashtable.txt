HashMap:
非线程安全、key\value允许null；
初始容量16，即Node[]的length,是数组的长度；
最大容量是2^30;
负载因子0.75，key\value键值对总数量>=容量*负载因子时，进行扩容，容量和扩容阈值（容量*负载因子）按2倍进行扩容；
桶中键值对数>=8时，链表转化为树；
桶中键值对数<=6时，树转化为链表；
红黑树：5个特性，变色，左旋，右旋

为什么负载因子时0.75?
    容量一定，因子越大，那么桶的长度就越长，空间利用率增大，查询的效率就会越低；因子越小，那么桶的长度就越小，空间利用率就降低，
查询效率就会增大。根据具体情况权衡。

计算元素的位置？
    hash()函数：key的hashCode异或(hashCode无符号右移16位），得到的值hash,通过(容量-1)与hash,计算出放置的实际位置

为什么key的hashCode异或(hashCode无符号右移16位）？
    hashCode是int类型，32位，相当于是原始哈希值的高16位异或上低16位,以此加大了低16位的随机性，混合后的低16位参杂了高16位的部分特征，
这样高位的信息也变相的保留了下来。

为什么(容量-1)与hash？
    容量是2的幂，即容量是偶数，偶数减去1，得到奇数，这个奇数对应的二进制数的末尾数字是1，那么与hash运算之后，可能是偶数也可能是
奇数，这样的运算结果将使数据均匀分布在数组上；若容量是奇数，那么减去1，得到偶数，这个偶数对应的二进制的末尾数字是0，那么与hash
运算之后，肯定是0，即一定是偶数，那么数组只有偶数位置有数据，这样的话，相当与数组有一半容量没用到。